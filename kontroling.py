# # print(100//33)
# # print(100/33)
# #print(100%33)



# #Kontrolni balik k dataclass
# # #
# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 497200
# #     Current mass in system          = 3.30057995e-20
# #     Linear momentum                 = (1.3883565e-21 7.71079581e-21 -8.75499278e-18)
# #    |Linear momentum|                = 8.75499629e-18
# #     Linear kinetic energy           = 1.92456112e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 2800, 1.85873368e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 644.39 s  ClockTime = 645 s

# # Time = 5.000e-07

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 495191
# #     Current mass in system          = 3.28724354e-20
# #     Linear momentum                 = (-2.43252934e-21 5.35636817e-21 -8.48197603e-18)
# #    |Linear momentum|                = 8.48197807e-18
# #     Linear kinetic energy           = 2.0131775e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 4809, 3.1923751e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 645.5 s  ClockTime = 646 s

# # Time = 6.000e-07

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 492977
# #     Current mass in system          = 3.27254627e-20
# #     Linear momentum                 = (-2.30044361e-21 1.27576372e-20 -8.21747986e-18)
# #    |Linear momentum|                = 8.21749008e-18
# #     Linear kinetic energy           = 2.09630948e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 7023, 4.66210238e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 646.61 s  ClockTime = 647 s

# # Time = 7.000e-07

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 490554
# #     Current mass in system          = 3.25646158e-20
# #     Linear momentum                 = (-1.13780264e-20 1.33190401e-20 -7.96372186e-18)
# #    |Linear momentum|                = 7.96374113e-18
# #     Linear kinetic energy           = 2.17110932e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 9446, 6.27057085e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 647.72 s  ClockTime = 648 s

# # Time = 8.000e-07

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 488025
# #     Current mass in system          = 3.23967323e-20
# #     Linear momentum                 = (-1.24381414e-20 1.07078477e-20 -7.71480876e-18)
# #    |Linear momentum|                = 7.71482622e-18
# #     Linear kinetic energy           = 2.24431642e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 11975, 7.94940566e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 648.85 s  ClockTime = 649 s

# # Time = 9.000e-07

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 485442
# #     Current mass in system          = 3.22252642e-20
# #     Linear momentum                 = (-1.01259426e-20 6.80670152e-21 -7.47306383e-18)
# #    |Linear momentum|                = 7.47307379e-18
# #     Linear kinetic energy           = 2.31305178e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 14558, 9.66408749e-22
# #       - stick                       = 0, 0

# # ExecutionTime = 649.97 s  ClockTime = 650 s

# # Time = 1.000e-06

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 482858
# #     Current mass in system          = 3.20537296e-20
# #     Linear momentum                 = (-3.97035951e-21 2.07043016e-21 -7.22784781e-18)
# #    |Linear momentum|                = 7.22784919e-18
# #     Linear kinetic energy           = 2.37511744e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 17142, 1.13794331e-21
# #       - stick                       = 0, 0

# # ExecutionTime = 655.01 s  ClockTime = 656 s

# # Time = 1.100e-06

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 480093
# #     Current mass in system          = 3.18701796e-20
# #     Linear momentum                 = (-5.76519368e-21 1.23939107e-21 -7.00096205e-18)
# #    |Linear momentum|                = 7.00096453e-18
# #     Linear kinetic energy           = 2.43227348e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 19907, 1.32149326e-21
# #       - stick                       = 0, 0

# # ExecutionTime = 656.13 s  ClockTime = 657 s

# # Time = 1.200e-06

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 477206
# #     Current mass in system          = 3.16785309e-20
# #     Linear momentum                 = (-1.03379092e-20 -8.19154099e-22 -6.77932443e-18)
# #    |Linear momentum|                = 6.77933236e-18
# #     Linear kinetic energy           = 2.48586642e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 22794, 1.51314198e-21
# #       - stick                       = 0, 0

# # ExecutionTime = 657.27 s  ClockTime = 658 s

# # Time = 1.300e-06

# # Evolving kinematicCloud

# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# #     Current number of parcels       = 474504
# #     Current mass in system          = 3.14991631e-20
# #     Linear momentum                 = (-5.1315199e-21 2.32986697e-21 -6.5596483e-18)
# #    |Linear momentum|                = 6.55965072e-18
# #     Linear kinetic energy           = 2.53902495e-15
# #     model1:
# #         number of parcels added     = 500000
# #         mass introduced             = 3.31916729e-20
# #     Parcel fate (number, mass)      : patch .*
# #       - escape                      = 25496, 1.69250978e-21
# #       - stick                       = 0, 0

# # ExecutionTime = 658.41 s  ClockTime = 659 s

# # Time = 1.400e-06

# # from dataclasses import dataclass, field
# # from typing import List, Tuple

# # @dataclass
# # class KinematicCloud:
# #     number_of_parcels: int
# #     current_mass: float
# #     linear_momentum: Tuple[float, float, float]
# #     linear_kinetic_energy: float
# #     model1: dict = field(default_factory=dict)
# #     execution_time: float = None
# #     clock_time: float = None
# #     time: float = None

# #     @classmethod
# #     def from_text(cls, text: str) -> 'KinematicCloud':
# #         data = {'model1': {}}
# #         lines = text.split('\n')
# #         for line in lines:
# #             if line.startswith('Current number of parcels'):
# #                 data['number_of_parcels'] = int(line.split('=')[-1].strip())
# #             elif line.startswith('Current mass in system'):
# #                 data['current_mass'] = float(line.split('=')[-1].strip())
# #             elif line.startswith('Linear momentum'):
# #                 momentum_values = [float(val) for val in line.split('=')[-1].strip().split()]
# #                 data['linear_momentum'] = tuple(momentum_values)
# #             elif line.startswith('Linear kinetic energy'):
# #                 data['linear_kinetic_energy'] = float(line.split('=')[-1].strip())
# #             elif line.startswith('model1:'):
# #                 current_model = 'model1'
# #             elif line.startswith('-'):
# #                 parts = line.split('=')
# #                 key = parts[0].strip().strip('-')
# #                 value = parts[1].split(',')
# #                 data[current_model][key] = (int(value[0].strip()), float(value[1]))
# #             elif line.startswith('ExecutionTime'):
# #                 data['execution_time'] = float(line.split('=')[-1].strip().split()[0])
# #             elif line.startswith('ClockTime'):
# #                 data['clock_time'] = float(line.split('=')[-1].strip().split()[0])
# #             elif line.startswith('Time'):
# #                 data['time'] = float(line.split('=')[-1].strip())

# #         return cls(**data)

# # # Příklad použití
# # text = """
# # Solving 3-D cloud kinematicCloud
# # Cloud: kinematicCloud
# # Current number of parcels       = 497200
# # Current mass in system          = 3.30057995e-20
# # Linear momentum                 = (1.3883565e-21 7.71079581e-21 -8.75499278e-18)
# # |Linear momentum|                = 8.75499629e-18
# # Linear kinetic energy           = 1.92456112e-15
# # model1:
# #     number of parcels added     = 500000
# #     mass introduced             = 3.31916729e-20
# # Parcel fate (number, mass)      : patch .*
# #   - escape                      = 2800, 1.85873368e-22
# #   - stick                       = 0, 0
# # ExecutionTime = 644.39 s  ClockTime = 645 s
# # Time = 5.000e-07
# # Evolving kinematicCloud
# # """

# # cloud = KinematicCloud.from_text(text)
# # print(cloud)

# # Tento algoritmus používá Python knihovnu dataclasses k definici datové třídy KinematicCloud, která reprezentuje odstavec z textového vstupu. Zde je popis, jak algoritmus funguje:

# # Nejprve importujeme dataclasses a definujeme datovou třídu KinematicCloud. Tato třída má různé atributy, které odpovídají různým částem odstavce. Některé z těchto atributů obsahují výchozí hodnoty.

# # V třídě KinematicCloud je definována metoda from_text, která slouží k vytvoření instance této třídy z textového vstupu.

# # V metodě from_text rozdělíme text na řádky pomocí split('\n') a procházíme každý řádek.

# # Postupně procházíme řádky textu a hledáme klíčová slova, která identifikují různé části odstavce, například "Current number of parcels", "Current mass in system" atd. Pokud najdeme odpovídající klíčové slovo, extrahujeme odpovídající hodnoty a ukládáme je do slovníku data.

# # Pokud narazíme na části textu, které patří pod klíčová slova "model1" nebo "Parcel fate", ukládáme tyto údaje do slovníku model1. Tyto části obsahují další údaje, které jsou také uloženy v textovém formátu.

# # Na závěr metody from_text vytvoříme instanci KinematicCloud s pomocí data, který obsahuje všechny extrahované údaje.

# # Po vytvoření instance KinematicCloud můžeme tuto instanci použít k uložení dat z textového vstupu do objektu, který lze snadno manipulovat a analyzovat pomocí Python kódu.

# # Tímto způsobem lze provést analýzu a zpracování textových dat z různých odstavců ve stejném formátu, jaký je uvedený v textu v otázce.

# ############################################################################################


# # Ú 4.1: Začíná, končí nebo obsahuje?
# # Úkol:
# # Na vstupu získáte dva řetezce oddělené mezerou. Otestujte jestli první řetězec začíná,
# # končí nebo aspoň obsahuje druhý řetězec. Možné výstupy:
# # • '…' starts and ends with '…'
# # • '…' starts with '…'
# # • '…' ends with '…'
# # • '…' contains '…'
# # • '…' does not contain '…'
# # (Místo … doplňte první a druhý řetězec.)
# # Vzorový vstup:
# # alobal al
# # Vzorový výstup:
# # 'alobal' starts and ends with 'al'
# # Vyzkoušejte také tyto vstupy:
# # bussiness bus
# # autobus bus
# # alobal oba
# # alobal bus

# # retezec = input("Zadej dve reteyzce oddělená mezerami: ").split()

# # if len(retezec) != 2:
# #     print("Zadal jsi jeden retezec.")

# # elif len(retezec) >= 2:
# #     r = str(retezec[0])
# #     #print(r)
# #     v = str(retezec[1])
# #     #print(v)

# #     zacatek_r = r[0]
# #     #print(zacatek_r)
# #     konec_r = r[len(r)-1]
# #     #print(konec_r)

# #     zacatek_v = v[0]
# #     #print(zacatek_v)
# #     konec_v = r[len(v)-1]
# #     #print(konec_v)

# #     if zacatek_r == zacatek_v and konec_r == konec_v:
# #         print(f" {r} + start with {zacatek_r} end with {konec_r}")




# # print(100//33)
# # print(100/33)
# # print(100%33)
# # from math import pi

# # def calculate_sphere_volumes(radii):
# #     volumes = []
# #     for i in range(3):
# #         if i < len(radii):
# #             if radii[i] is not None:
# #                 volume = (4 / 3) * pi * ((radii[i] / 2) ** 3)
# #             else:
# #                 volume = 0
# #         else:
# #             volume = 0
# #         volumes.append(volume)
# #     return volumes

# # # Příklady použití
# # radii_1 = [5, 9]  # Dva poloměry
# # radii_2 = [3.9, None, 2]  # Tři poloměry, jeden chybí
# # radii_3 = [3.9, 2]  # Dva poloměry
# # radii_4 = []  # Prázdný seznam
# # radii_5 = [7]  # Seznam s jedním prvkem

# # volumes_1 = calculate_sphere_volumes(radii_1)
# # volumes_2 = calculate_sphere_volumes(radii_2)
# # volumes_3 = calculate_sphere_volumes(radii_3)
# # volumes_4 = calculate_sphere_volumes(radii_4)
# # volumes_5 = calculate_sphere_volumes(radii_5)

# # print("Objemy koulí (radii_1):", volumes_1)
# # print("Objemy koulí (radii_2):", volumes_2)
# # print("Objemy koulí (radii_3):", volumes_3)
# # print("Objemy koulí (radii_4):", volumes_4)
# # print("Objemy koulí (radii_5):", volumes_5)



# # veta = " martin pavel hovno leze travou"
# # veta = veta.split()
# # print(veta)


# # slovo = "martin"

# # nove_slovo = []

# # for pismeno in slovo:

# #     nove_slovo.append(pismeno)

# # pozpatku_slovo = nove_slovo.reverse()

# # print(nove_slovo)


# # pozpatku_slovo = ''.join(pozpatku_slovo)
# # print(pozpatku_slovo)

# # ####################################################
# # slovo = "martin"

# # nove_slovo = []

# # for pismeno in slovo:
# #     nove_slovo.append(pismeno)

# # nove_slovo.reverse()  # Otočení seznamu in-place

# # print(nove_slovo)  # Vypíše seznam písmen pozpátku

# # pozpatku_slovo = ''.join(nove_slovo)  # Spojení písmen do řetězce
# # print(pozpatku_slovo)  # Vypíše slovo pozpátku




# ########################################################################################

# # def print_dict(dictionary: dict, title: str = "dict", reverse_order: bool = False) -> None:
# #     # Výpis nadpisu a počtu klíčů
# #     print(f"{title} [{len(dictionary)}]:")

# #     # Seřazení klíčů slovníku
# #     sorted_keys = sorted(dictionary.keys(), reverse=reverse_order)

# #     # Výpis dvojic klíč:hodnota
# #     for key in sorted_keys:
# #         value = dictionary[key]
# #         print(f"    {key}: {value}")

# # # Příklady použití
# # print_dict({'bob': 10, 'cyril': 6, 'alice': 9}, title='Skóre v Kloboučku Hop')
# # print_dict({1: 1, 3: 9, 5: 25, 2: 4, 4: 16}, reverse_order=True)


# # def print_dict(dictionary, title):
# #     sorted_dict = dict(sorted(dictionary.items(), key=lambda item: item[0]))
    
# #     print(f"{title} [{len(sorted_dict)}]:")
    
# #     for key, value in sorted_dict.items():
# #         print(f"    {key}: {value}")

# # print_dict({'bob': 10, 'cyril': 6, 'alice': 9}, title='Skóre v Kloboučku Hop')



# # def print_dict_with_key(dictionary, title):
# #     print(f"{title} [{len(dictionary)}]:")
    
# #     for key, value in dictionary.items():
# #         print(f"{key}: {value}")

# # # Příklad použití
# # my_dict = {'bob': 10, 'cyril': 6, 'alice': 9}
# # print_dict_with_key(my_dict, title='Skóre v Kloboučku Hop')



# # def print_dict(dictionary: dict, title: str) -> None:
# #     pocet_klicu_ve_slovniku = len(dictionary)
# #     print(f"    {title}  [{pocet_klicu_ve_slovniku}]")

# #     serazeny_slovnik_dle_klice = sorted(dictionary.items())
    
# #     for key, value in serazeny_slovnik_dle_klice:
# #         print(f"{key}: {value}")

# # print_dict({'bob': 10, 'cyril': 6, 'alice': 9}, title='Skóre v Kloboučku Hop')


# # def mode(elements: list[object]) -> object:
# #     if not elements:  # Pokud je seznam prázdný, vrátíme None
# #         return None

# #     cetnosti = {}  # Slovník pro uchování četností hodnot

# #     for item in elements:
# #         if item in cetnosti:
# #             cetnosti[item] += 1
# #         else:
# #             cetnosti[item] = 1

# #     # Najdeme hodnotu s nejvyšší četností (modus)
# #     modus = max(cetnosti, key=cetnosti.get)
    
# #     return modus

# # # Příklady použití:
# # print(mode([1, 2, 3, 3, 4, 4, 1, 2, 5, 3, 2, 1, 2]))  # Vrací 2
# # print(mode(['jablko', 'pomeranč', 'hruška', 'pomeranč', 'jablko', 'jablko', 'hruška']))  # Vrací 'jablko'


# # def mode(elements: list[object]) -> object:
# #     if not elements:
# #         return None

# #     # Vytvoříme slovník, kde klíče budou prvky ze vstupního seznamu a hodnoty budou četnosti těchto prvků.
# #     counts = {}
# #     for item in elements:
# #         if item in counts:
# #             counts[item] += 1
# #         else:
# #             counts[item] = 1

# #     # Najdeme maximum v počtech výskytů.
# #     max_count = max(counts.values())

# #     # Zjistíme, které prvky mají tento počet výskytů (mohou být více modů).
# #     modes = [key for key, value in counts.items() if value == max_count]

# #     # Vrátíme jeden z prvků, které jsou modem.
# #     return modes[0]

# # # Příklady použití
# # print(mode([1, 2, 3, 3, 4, 4, 1, 2, 5, 3, 2, 1, 2]))
# # print(mode([]))
# # print(mode([11, 55, 55, 11]))







# # du_X_Y.py
# # V úkolech v této sadě je potřeba (narozdíl od předchozích sad) vždy zadefinovat neakou funkci. Není třeba načítat vstup pomocí funkce input, testy budou volat Vaši
# # funkci tak, jak uvádí vzorové volání.
# # Pokud je uvedené vzorové volání a vzorový výsledek, chce se od Vás, aby návratovou
# # hodnotou vzorového volání byl vzorový výsledek (return).
# # Pokud je uvedené vzorové volání a vzorový výstup, nemá funkce vracet žádnou
# # návratovou hodnotou, ale má vypisovat vzorový výstup (print).
# # Úkol 3 (10 bodů)
# # V tomto úkolu budeme řešit dvojsměrku – jednodušší verzi osmisměrky. Zadání dvojsměrky sestává z dlouhého řetězce písmen
# #  a seznamu hledaných slov. Tato slova
# # potřebujeme najít v řetězci a škrtnout je. Slova mohou být v řetězci zapsána zleva
# # doprava nebo zprava doleva. Tajenku pak získáme spojením zbylých neškrtnutých
# # písmen.
# # Doplňte funkci solve_puzzle, která bere dva argumenty – řetězec písmen a seznam
# # hledaných slov. Návratovou hodnotou funkce bude vyluštěná tajenka.
# # Příklad dvojsměrky:
# # ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM
# # Hledaná slova: FUNKCE MOST MYŠ STROM VÝLET ŠTVANEC
# # Řešení:
# # Po vyškrtnutí všech hledaných slov jsme našli tajenku: ZIMA.
# # Vzorové volání:
# # solve_puzzle('ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM', ['FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC'])
# # Vzorový výsledek:
# # 'ZIMA'
# # [ ]: from __future__ import annotations
# # def solve_puzzle(text: str, words: list[str]) -> str:
# # 3
# # ...
# # # solve_puzzle('ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM', ['FUNKCE', 'MOST',␣
# # ↪'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC']) # 'ZIMA'
# # # solve_puzzle('AZÁVSVBANÁNAPOKRMAKOŽÍŠEKARAMŘLIBOMÁZUBYK', ['BANÁN',␣
# # ↪'KOPANÁ', 'KOŽÍŠEK', 'MARAKEŠ', 'MOBIL', 'POKRM', 'VÁZA', 'ZUBY'])␣
# # ↪ # 'SVAŘÁK'
# # # solve_puzzle('ŽALHICHLAPATITCPESPEKSUKRUMORRSOLONOHTYPVČIBALGINÍ',␣
# # ↪['APATIT', 'BIČ', 'CHLAP', 'CIHLA', 'IBALGIN', 'LOS', 'MOR',␣
# # ↪'PES', 'PYTHON', 'RUM', 'SKEPSE', 'ŽAL']) # 'CUKROVÍ



# # words = "'FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC'"
# # text =  "ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM"
# # text_pozpatku = text[::-1]

# # words = words.replace("'", "") # Odstraníme jednoduché uvozovky kolem slov
# # words = words.split(', ') # Rozdělíme slova do seznamu na základě čárky a mezer
# # zjistena_pismena = []

# # # for i in words:
# # #     if i in text:
# # #         a = i
# # #         zjistena_pismena.append(a)

# # # print(zjistena_pismena)

# # def kontrola_obsahu_slov(words, text):
# #     zjistena_pismena = []
# #     for i in words:
# #         if i in text:
# #             a = i
# #             zjistena_pismena.append(a)

# #     return zjistena_pismena

# # zjistena_pismena_popredu = kontrola_obsahu_slov(words, text)
# # zjistena_pismena_pozadu= kontrola_obsahu_slov(words, text_pozpatku)      
# # # print(zjistena_pismena_popredu)
# # # print(zjistena_pismena_pozadu)


# # def prevod_listu_na_str(list):

# #     # list = ['FUNKCE', 'MOST', 'STROM', 'VÝLET']
# #     prevedeny_list_na_str = ', '.join(list)
# #     return prevedeny_list_na_str
    
    
# # prevod_listu_na_str_popredu = prevod_listu_na_str(zjistena_pismena_popredu)
# # prevod_listu_na_str_pozadu = prevod_listu_na_str(zjistena_pismena_pozadu)

# # print(prevod_listu_na_str_popredu)
# # print(prevod_listu_na_str_pozadu)
# # novyText = ''
# # text = "kjhkjhl"
# # for i in text:

# #     novyText = novyText + i

# # print(novyText)



# words = "'FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC'"
# text =  "ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM"
# text_pozpatku = text[::-1]

# words = words.replace("'", "") # Odstraníme jednoduché uvozovky kolem slov
# words = words.split(', ') # Rozdělíme slova do seznamu na základě čárky a mezer
# zjistena_pismena = []

# # for i in words:
# #     if i in text:
# #         a = i
# #         zjistena_pismena.append(a)

# # print(zjistena_pismena)





# def kontrola_obsahu_slov(words, text):
#     zjistena_pismena = []
#     for i in words:
#         if i in text:
#             a = i
#             zjistena_pismena.append(a)

#     return zjistena_pismena

# zjistena_pismena_popredu = kontrola_obsahu_slov(words, text)
# zjistena_pismena_pozadu= kontrola_obsahu_slov(words, text_pozpatku)      
# print(zjistena_pismena_popredu)
# print(zjistena_pismena_pozadu)



# novy_relokacni_str = text - words[0]

# novy_relokacni_str = text - words[1]

# pater pat er 

# er

# __path__



# # def prevod_listu_na_str(list):

# #     # list = ['FUNKCE', 'MOST', 'STROM', 'VÝLET']
# #     prevedeny_list_na_str = ', '.join(list)
# #     return prevedeny_list_na_str
    
    
# # prevod_listu_na_str_popredu = prevod_listu_na_str(zjistena_pismena_popredu)
# # prevod_listu_na_str_pozadu = prevod_listu_na_str(zjistena_pismena_pozadu)

# # print(prevod_listu_na_str_popredu)
# # print(prevod_listu_na_str_pozadu)

# # # zbyla_pismena_popredu = text - prevod_listu_na_str_popredu


# # prevod_listu_na_str_popredu_na_jeden_str = prevod_listu_na_str_popredu.replace(", ", "") # Odstraní čárky a mezery
# # jeden_text_popredu = "".join(prevod_listu_na_str_popredu_na_jeden_str.split())
# # # print(jeden_text_popredu)
# # prevod_listu_na_str_pozadu_na_jeden_str = prevod_listu_na_str_pozadu.replace(", ", "") # Odstraní čárky a mezery
# # jeden_text_pozadu = "".join(prevod_listu_na_str_pozadu_na_jeden_str.split())
# # # print(jeden_text_pozadu)

# # for i in jeden_text_popredu:

# #     # rozepisu char z jeden_text_popredu/pozadu a porovnam na textu
# #     zbyla_pismena_popredu =''
# #     if i in text:

# #         zbyla_pismena_popredu = zbyla_pismena_popredu + i

# #     print(f"{zbyla_pismena_popredu}...........")


def solve_puzzle(text, slova):
  """Vyřeší křížovku.

  Args:
    text: Text křížovky.
    slova: Seznam slov, která se v křížovce nacházejí.

  Returns:
    Vyřešená křížovka.
  """
################################################################################################
#   tajenka = ''
#   for i, znak in enumerate(text):
#     for slovo in slova:
#       if slovo.startswith(znak):
#         tajenka += slovo[i]
#         slova.remove(slovo)
#         break
#   return tajenka


# text = 'ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM'
# slova = ['FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC']
# tajenka = solve_puzzle(text, slova)
# print(tajenka)  # Výstup: 'ZIMA'
############################################################################################33
# def solve_puzzle(text: str, words: list[str]) -> str:
#     tajenka = list(text)  # Převedeme řetězec na seznam znaků

#     for slovo in words:
#         if slovo in ''.join(tajenka):
#             for i in range(len(tajenka) - len(slovo) + 1):
#                 if ''.join(tajenka[i:i + len(slovo)]) == slovo:
#                     for j in range(len(slovo)):
#                         tajenka[i + j] = ' '

#     tajenka = ''.join(tajenka)
#     tajenka = tajenka.replace(' ', '')

#     return tajenka

# # Příklad použití
# text = 'ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM'
# slova = ['FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC']
# tajenka = solve_puzzle(text, slova)
# print(tajenka)  # Výstup: 'ZIMA'
#############################################################################################


# def solve_puzzle(text: str, words: list[str]) -> str:
#     tajenka = ''
#     for i, znak in enumerate(text):
#         for slovo in slova:
#             if slovo.startswith(znak):
#                 tajenka += slovo[i]
#                 slova.remove(slovo)
#                 break
#     return tajenka

# text = 'ZFUNKCENAVTŠIMOSTROMMVÝLETAŠYM'
# slova = ['FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC']
# tajenka = solve_puzzle(text, slova)
# print(tajenka)  # Výstup: 'ZIMA'


##################################################################################

# seznam = ['FUNKCE', 'MOST', 'MYŠ', 'STROM', 'VÝLET', 'ŠTVANEC']
# sestavene_seznam = sorted(seznam)  # Vytvoří nový seřazený seznam
# print(sestavene_seznam)
# vstup = int(input())

# def dvojciferne(vstup: int) -> bool:

#     cislo = list(str(vstup))

#     print(cislo)





# # a = [float(x) for x in input().split()] # vstu

# def nasobkysedmi(vstup: int) -> bool:

#     if vstup % 7 == 0:
#         return False
    
#     else:
#         return True
    
# print(nasobkysedmi(21))

# a =  9//2
# print(a)

# my_list = [1, 2, 3, 4, 5]

# # Vytvoříme řetězec, kde každá položka z listu je na samostatném řádku
# result = "\n".join(map(str, my_list))

# # Výsledek obsahuje každou položku na samostatném řádku
# print(result)


# vstup = "adfadfads"
# for i in vstup:
#   print(i)

#   def slovnik_unicode():
#     #dela to unicode slovnik a vraci ho

#     unicode_slovnik = {}

#     for znak in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789":
#         unicode_hodnota = ord(znak)
#         unicode_slovnik[znak] = unicode_hodnota

#     return unicode_slovnik

# unicode_slovnik = slovnik_unicode()

# print(slovnik_unicode())
# slovnik = {"a": 10, "b": 77}
# seznam = [10, 10, 77, 99]

# # Vytvoření nového seznamu klíčů z hodnot ze slovníku
# novy_seznam = [klic for hodnota in seznam for klic, h in slovnik.items() if h == hodnota]

# print(novy_seznam)


# vstup = input()  # Přečteme vstupní řádek textu
# pismena = []  # Inicializace seznamu pro ukládání písmen

# for znak in vstup:
#     if znak.isalpha():  # Kontrola, zda je znak písmeno
#         pismena.append(znak.upper())  # Přidáme písmeno (velká písmena) do seznamu

# # Seřadíme seznam písmen a převedeme ho na řetězec
# vystup = ''.join(sorted(pismena))

# print(vystup)  # Vypíšeme všechna písmena (velká) v abecedním pořadí


# vstup = input()  # Přečteme vstupní řádek textu

# # Inicializace množiny pro ukládání písmen
# pismena = set()

# for znak in vstup:
#     if znak.isalpha():  # Kontrola, zda je znak písmeno
#         pismena.add(znak.upper())  # Přidáme písmeno (ve formě velkých písmen) do množiny

# # Seřadíme písmena v abecedním pořadí a převedeme je na řetězec
# vystup = ''.join(sorted(pismena))

# print(vystup)  # Vypíšeme všechna písmena (velká) v abecedním pořadí

print(100//33)
print(100/33)
print(100%33)

